# Лекция 4. Основы многопоточности и асинхронности в .NET

Основы многопоточности и асинхронности в .NET: от потоков и задач до `async`/`await`.

**Цель:** Дать студентам понимание фундаментальных концепций параллельного и асинхронного программирования, объяснить их различия и показать практическое применение в современных .NET приложениях.

---

### **План лекции:**

1.  **Введение: Зачем нужна многопоточность и асинхронность?**
    *   Проблемы однопоточных приложений (UI "зависает", низкая производительность).
    *   Цели: Отзывчивость, производительность, эффективное использование ресурсов.
2.  **Потоки (Threading) - фундамент**
    *   Что такое поток?
    *   Класс `Thread`.
    *   Проблемы потокобезопасности и способы их решения (`lock`, `Monitor`, `Mutex`).
3.  **Пул потоков (ThreadPool) и задача (Task)**
    *   Почему `Thread` — это дорого?
    *   Класс `ThreadPool` для управления потоками.
    *   **Task Parallel Library (TPL)**: Класс `Task` как современная абстракция над потоком.
4.  **Асинхронность: Модель `async`/`await`**
    *   Чем асинхронность отличается от многопоточности?
    *   Ключевые слова `async` и `await`.
    *   Как это работает под капотом? (State Machine, `Task`).
    *   Возвращаемые типы: `Task`, `Task<T>`, `ValueTask<T>`.
5.  **Параллельное программирование: `Parallel` класс**
    *   `Parallel.For` и `Parallel.ForEach` для обработки данных.
    *   Отличия от `Task` и `async`/`await`.
6.  **Работа с коллекциями в многопоточных сценариях**
    *   Потокобезопасные коллекции (`ConcurrentBag<T>`, `ConcurrentDictionary<TKey, TValue>` и др.).
7.  **Типичные ошибки и лучшие практики**
    *   `async void` (почему это опасно?).
    *   `.ConfigureAwait(false)`.
    *   Деадлоки (взаимные блокировки) и как их избегать.
    *   Отмена операций с помощью `CancellationToken`.

---

### **Подробное рассмотрение каждого пункта плана:**

#### **1. Введение: Зачем нужна многопоточность и асинхронность?**

**Проблема:** Представьте desktop-приложение (WPF/WinForms). Когда пользователь нажимает кнопку "Загрузить данные", и весь процесс выполняется в UI-потоке, интерфейс перестает откликаться — кнопки не нажимаются, окно "зависает", пока данные не будут загружены. То же в серверных приложениях (ASP.NET Core): если запрос выполняет долгую операцию (обработка файла, запрос к БД) синхронно, поток сервера блокируется и не может обрабатывать новые запросы, снижая общую пропускную способность.

**Цели:**
*   **Отзывчивость UI:** Главный поток приложения всегда свободен для реакции на действия пользователя.
*   **Производительность:** Распараллеливание вычислений на многоядерных процессорах (например, обработка изображений).
*   **Масштабируемость (Серверы):** Эффективное обслуживание множества одновременных запросов, не блокируя потоки.

---

#### **2. Потоки (Threading) - фундамент**

**Поток** — это наименьшая единица выполнения внутри процесса. Процесс может содержать несколько потоков, которые выполняются параллельно и разделяют ресурсы (память).

**Класс `System.Threading.Thread`:**

```csharp
// Простой пример создания и запуска потока
Thread thread = new Thread(new ThreadStart(DoWork));
thread.Start(); // Запуск метода DoWork в отдельном потоке

void DoWork()
{
    for (int i = 0; i < 10; i++)
    {
        Console.WriteLine($"Поток: {Thread.CurrentThread.ManagedThreadId}, i = {i}");
        Thread.Sleep(500); // Имитация работы
    }
}
```

**Проблемы потокобезопасности:**
Когда несколько потоков обращаются к общим данным без синхронизации, возникает состояние гонки (Race Condition).

```csharp
int _counter = 0; // Общий ресурс

void UnsafeIncrement()
{
    for (int i = 0; i < 10000; i++)
    {
        _counter++; // Эта операция не атомарна!
    }
}

// Запуск двух потоков
Thread t1 = new Thread(UnsafeIncrement);
Thread t2 = new Thread(UnsafeIncrement);
t1.Start();
t2.Start();
t1.Join();
t2.Join();

Console.WriteLine($"Ожидалось: 20000, Получилось: {_counter}"); // Результат будет меньше 20000!
```

**Решение: Синхронизация с помощью `lock`:**

```csharp
private readonly object _lockObject = new object();
int _counter = 0;

void SafeIncrement()
{
    for (int i = 0; i < 10000; i++)
    {
        lock (_lockObject) // Только один поток может войти в этот блок
        {
            _counter++;
        }
    }
}
// Теперь результат всегда будет 20000.
```

---

#### **3. Пул потоков (ThreadPool) и задача (Task)**

**Проблема `Thread`:** Создание нового потока — дорогая операция (~1 МБ памяти, время на инициализацию).

**Решение: `ThreadPool`.** Это набор уже созданных потоков, готовых к работе. Вы не создаете поток, а запрашиваете его из пула.

**Современный подход: Task Parallel Library (TPL) и класс `Task`.** `Task` представляет собой асинхронную операцию, которая может выполняться в потоке из `ThreadPool`.

```csharp
// Создание и запуск Task
Task task = Task.Run(() =>
{
    // Этот код выполняется в потоке из пула
    Console.WriteLine($"Task выполняется в потоке {Thread.CurrentThread.ManagedThreadId}");
    Thread.Sleep(1000);
    Console.WriteLine("Task завершен.");
});

task.Wait(); // Блокирует текущий поток до завершения Task (не рекомендуется в UI)
```

**Преимущества `Task` перед `Thread`:**
*   Эффективное использование потоков.
*   Возможность цепочек вызовов (`.ContinueWith`).
*   Упрощенная обработка ошибок и отмены.
*   Интеграция с `async`/`await`.

---

#### **4. Асинхронность: Модель `async`/`await`**

**Ключевое различие:**
*   **Многопоточность** — о *работе* (использовании нескольких ядер CPU).
*   **Асинхронность** — о *ожидании* (освобождении потока во время операций ввода-вывода, например, чтения файла, запроса к БД или API).

**`async`/`await`** — это модель, которая позволяет писать код, который выглядит как синхронный, но выполняется асинхронно.

```csharp
// Синхронный метод (плохо для UI/сервера)
public string DownloadData(string url)
{
    using var httpClient = new HttpClient();
    return httpClient.GetStringAsync(url).Result; // .Result - БЛОКИРУЕТ поток!
}

// Асинхронный метод (правильно)
public async Task<string> DownloadDataAsync(string url)
{
    using var httpClient = new HttpClient();
    return await httpClient.GetStringAsync(url); // Поток освобождается во время ожидания!
}

// Использование в UI
private async void Button_Click(object sender, EventArgs e)
{
    string data = await DownloadDataAsync("https://api.example.com/data");
    textBox.Text = data; // Этот код автоматически вернется в UI-поток!
}
```

**Как это работает?**
Компилятор преобразует `async`-метод в машину состояний (State Machine). Когда выполнение доходит до `await`, если операция еще не завершена, метод возвращает управление вызывающему коду, а поток освобождается. Когда фоновая операция завершается, машина состояний продолжает выполнение (часто в том же контексте синхронизации, например, в UI-потоке).

**Возвращаемые типы:**
*   `Task`: для асинхронных операций, не возвращающих значение.
*   `Task<T>`: для асинхронных операций, возвращающих значение типа `T`.
*   `ValueTask<T>`: оптимизация для случаев, когда результат часто доступен синхронно.

---

#### **5. Параллельное программирование: `Parallel` класс**

Используется для **параллельной обработки данных** (CPU-bound операции), когда у вас есть большой объем вычислений, которые можно разделить.

```csharp
int[] numbers = Enumerable.Range(1, 1000000).ToArray();

// Последовательная обработка
foreach (var number in numbers)
{
    Process(number);
}

// Параллельная обработка (использует все доступные ядра)
Parallel.ForEach(numbers, number =>
{
    Process(number);
});

// Или Parallel.For
Parallel.For(0, numbers.Length, i =>
{
    Process(numbers[i]);
});
```

**Важно:** `Parallel` класс блокирует вызывающий поток до завершения всей параллельной работы. Используйте для CPU-bound задач. Для I/O-bound задач используйте `async`/`await`.

---

#### **6. Работа с коллекциями в многопоточных сценариях**

Обычные коллекции (`List<T>`, `Dictionary<TKey, TValue>`) не являются потокобезопасными. Используйте коллекции из пространства имен `System.Collections.Concurrent`.

```csharp
var concurrentBag = new ConcurrentBag<int>();
var concurrentDict = new ConcurrentDictionary<string, int>();

Parallel.For(0, 1000, i =>
{
    concurrentBag.Add(i); // Безопасно из множества потоков
    concurrentDict.TryAdd($"Key_{i}", i);
});
```

---

#### **7. Типичные ошибки и лучшие практики**

*   **`async void`:** Используйте только для обработчиков событий (например, `button_Click`). Для всех остальных методов используйте `async Task`. `async void` нельзя ожидать (`await`), и исключения в нем могут "уронить" приложение.
    *   **Плохо:** `public async void LoadData() { ... }`
    *   **Хорошо:** `public async Task LoadDataAsync() { ... }`

*   **`.ConfigureAwait(false)`:**
    Сообщает машине состояний, что не обязательно возобновлять выполнение в исходном контексте синхронизации. Это предотвращает возможные деадлоки и немного повышает производительность в библиотечном коде.
    ```csharp
    public async Task<string> GetDataAsync()
    {
        var data = await httpClient.GetStringAsync("url").ConfigureAwait(false);
        // Этот код может выполниться в любом потоке из пула.
        return Process(data);
    }
    ```

*   **Деадлоки:**
    Возникают, когда два или более потока блокируют друг друга.
    ```csharp
    // Классический деадлок
    private readonly object lock1 = new object();
    private readonly object lock2 = new object();

    void Method1()
    {
        lock (lock1)
        {
            Thread.Sleep(1000);
            lock (lock2) { /* ... */ } // Деадлок! Method2 уже захватил lock2.
        }
    }
    void Method2()
    {
        lock (lock2)
        {
            Thread.Sleep(1000);
            lock (lock1) { /* ... */ } // Деадлок! Method1 уже захватил lock1.
        }
    }
    ```
    **Решение:** Упорядочивайте захват блокировок или используйте `Monitor.TryEnter` с таймаутом.

*   **Отмена операций с `CancellationToken`:**
    Позволяет корректно отменять длительные операции.
    ```csharp
    public async Task LongOperationAsync(CancellationToken cancellationToken = default)
    {
        for (int i = 0; i < 100; i++)
        {
            cancellationToken.ThrowIfCancellationRequested(); // Проверка на отмену
            await Task.Delay(1000, cancellationToken); // Задержка, которая тоже может быть отменена
            // ... работа
        }
    }

    // Использование
    var cts = new CancellationTokenSource();
    var task = LongOperationAsync(cts.Token);
    // ... через некоторое время
    cts.Cancel(); // Инициировать отмену
    ```

---

### **Резюме:**

*   **Многопоточность** — инструмент для распараллеливания **вычислений** (CPU-bound).
*   **Асинхронность** — инструмент для эффективного **ожидания** (I/O-bound).
*   **`Task` и TPL** — современная и рекомендуемая абстракция для работы с параллелизмом.
*   **`async`/`await`** — синтаксический сахар, который делает асинхронный код простым и читаемым.
*   Всегда помните о **потокобезопасности** и используйте соответствующие примитивы синхронизации.
*   Избегайте **блокировок потоков** (`.Result`, `.Wait()`) в асинхронном коде. Вместо этого используйте `await`.
*   Используйте **`CancellationToken`** для реализации отмены операций.

### **Контрольные вопросы:**

1.  В чем основное различие между потоком (`Thread`) и задачей (`Task`)?
2.  Объясните, чем многопоточность (parallelism) принципиально отличается от асинхронности (asynchrony). Приведите примеры задач для каждого подхода.
3.  Что такое "состояние гонки" (Race Condition) и как его можно предотвратить в .NET?
4.  Почему использование `lock` может привести к деадлоку (взаимной блокировке)?
5.  Что произойдет, если вызвать `async void` метод и в нем возникнет исключение?
6.  Для чего нужен метод `.ConfigureAwait(false)`? В каком коде его стоит использовать?
7.  Какой класс вы бы использовали для параллельной обработки большого массива данных: `Parallel` или запустили бы несколько `Task`? Обоснуйте ответ.
8.  Что делает ключевое слово `await` "под капотом"?
9.  Когда следует использовать потокобезопасные коллекции (`ConcurrentBag`, `ConcurrentDictionary`)?
10. Как правильно реализовать отмену длительной асинхронной операции?