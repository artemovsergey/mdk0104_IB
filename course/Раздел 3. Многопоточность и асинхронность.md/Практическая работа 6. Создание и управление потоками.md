# Практическая работа 6. Создание и управление потоками

### Цель работы

Научиться создавать и управлять потоками в C#. Освоить работу с классами `Thread`, `Task`, а также базовые принципы многопоточности и синхронизации.

---

## **Теоретическая часть**

1. **Потоки (Threads)**

   * Поток — это отдельная линия выполнения кода внутри программы.
   * Класс `Thread` позволяет создавать и запускать потоки.
   * Основные методы:

     * `Start()` — запуск потока
     * `Join()` — ожидание завершения потока
     * `Sleep(int ms)` — приостановка потока на указанное время

   **Пример:**

   ```csharp
   using System;
   using System.Threading;

   class Program
   {
       static void PrintNumbers()
       {
           for (int i = 1; i <= 5; i++)
           {
               Console.WriteLine(i);
               Thread.Sleep(500); // пауза 0,5 секунды
           }
       }

       static void Main()
       {
           Thread t = new Thread(PrintNumbers);
           t.Start();
           t.Join();
           Console.WriteLine("Поток завершён");
       }
   }
   ```

2. **Класс Task**

   * Современный способ работы с потоками — асинхронные задачи (`Task`).
   * Позволяет проще управлять результатами и обработкой исключений.

   ```csharp
   using System;
   using System.Threading.Tasks;

   class Program
   {
       static async Task Main()
       {
           Task t = Task.Run(() => Console.WriteLine("Hello from Task!"));
           await t;
       }
   }
   ```

3. **Синхронизация потоков**

   * Класс `lock` — предотвращает одновременный доступ к общим данным.

   ```csharp
   class Counter
   {
       private int count = 0;
       private object lockObj = new object();

       public void Increment()
       {
           lock (lockObj)
           {
               count++;
               Console.WriteLine(count);
           }
       }
   }
   ```

4. **Основные ошибки**

   * Гонки потоков (Race condition)
   * Доступ к общим ресурсам без синхронизации
   * Блокировки и взаимные ожидания (Deadlock)

---

## **Ход работы**

1. Создать проект `ThreadDemo` (консольное приложение .NET).
2. Реализовать метод, выполняющий какую-либо работу (например, вывод чисел, подсчёт суммы).
3. Создать несколько потоков для параллельного выполнения этого метода.
4. Продемонстрировать работу `Thread.Sleep`, `Join` и `lock`.
5. Сделать скриншоты работы программы и поместить их в папку `images`.
6. Создать `readme.md` с описанием задания и примером кода.

---

## **Пример практического задания**

**Задание:**

1. Создать класс `Counter` с методом `CountNumbers()`, который выводит числа от 1 до 5 с задержкой.
2. Создать два потока, которые выполняют `CountNumbers()` одновременно.
3. Использовать `lock` для синхронизации вывода.
4. В `Main` запустить потоки и дождаться их завершения.
5. Вывести сообщение о завершении работы всех потоков.

**Пример кода:**

```csharp
using System;
using System.Threading;

class Counter
{
    private object lockObj = new object();

    public void CountNumbers(string threadName)
    {
        lock (lockObj)
        {
            for (int i = 1; i <= 5; i++)
            {
                Console.WriteLine($"{threadName}: {i}");
                Thread.Sleep(500);
            }
        }
    }
}

class Program
{
    static void Main()
    {
        Counter counter = new Counter();

        Thread t1 = new Thread(() => counter.CountNumbers("Поток 1"));
        Thread t2 = new Thread(() => counter.CountNumbers("Поток 2"));

        t1.Start();
        t2.Start();

        t1.Join();
        t2.Join();

        Console.WriteLine("Все потоки завершены");
    }
}
```

---

## **Критерии оценки**

| Оценка | Критерий                                                                                                                   |
| ------ | -------------------------------------------------------------------------------------------------------------------------- |
| 2      | Программа частично работает, поток запускается некорректно                                                                 |
| 3      | Потоки создаются и выполняются корректно, синхронизация частично реализована                                               |
| 4      | Все потоки работают корректно, вывод синхронизирован, ошибки обработки отсутствуют                                         |
| 5      | Отличная реализация, несколько потоков, правильная синхронизация, аккуратный код, скриншоты и readme выполнены качественно |

---

## **Контрольные вопросы**

1. Чем поток отличается от обычного последовательного выполнения программы?
2. Какие методы класса `Thread` используются для управления потоками?
3. Как синхронизировать доступ нескольких потоков к общим данным?
4. Что такое гонки потоков и как их избежать?
5. Чем `Task` отличается от `Thread`?

---

## **Структура репозитория**

```
ThreadDemo/
│
├── ThreadDemo.sln
├── ThreadDemo/
│   ├── Program.cs
│   └── Counter.cs
│
├── images/
│   ├── screenshot1.png
│   └── screenshot2.png
│
└── readme.md
```

### **Пример readme.md**

````markdown
# Практическая работа №6

**Тема:** Создание и управление потоками  

## Задание
1. Создать класс Counter с методом CountNumbers(), который выводит числа от 1 до 5 с задержкой.
2. Создать два потока, которые выполняют CountNumbers() одновременно.
3. Использовать lock для синхронизации вывода.
4. В Main запустить потоки и дождаться их завершения.
5. Вывести сообщение о завершении работы всех потоков.

## Пример кода
```csharp
using System;
using System.Threading;

class Counter
{
    private object lockObj = new object();

    public void CountNumbers(string threadName)
    {
        lock (lockObj)
        {
            for (int i = 1; i <= 5; i++)
            {
                Console.WriteLine($"{threadName}: {i}");
                Thread.Sleep(500);
            }
        }
    }
}

class Program
{
    static void Main()
    {
        Counter counter = new Counter();

        Thread t1 = new Thread(() => counter.CountNumbers("Поток 1"));
        Thread t2 = new Thread(() => counter.CountNumbers("Поток 2"));

        t1.Start();
        t2.Start();

        t1.Join();
        t2.Join();

        Console.WriteLine("Все потоки завершены");
    }
}
```

```