# Практическая работа  7. Синхронизация потоков (lock, Monitor, Mutex)

### Цель работы

Научиться синхронизировать потоки в C# с помощью конструкций `lock`, `Monitor` и `Mutex`. Освоить предотвращение гонок потоков и корректное управление доступом к общим ресурсам.

---

## **Теоретическая часть**

1. **Проблема гонок потоков**

   * Гонки (Race Condition) возникают, когда несколько потоков одновременно обращаются к общему ресурсу, что может привести к непредсказуемым результатам.

2. **`lock`**

   * Простая и безопасная конструкция для синхронизации потоков.
   * Блокирует объект, пока один поток выполняет критическую секцию.

   ```csharp
   private object lockObj = new object();
   lock (lockObj)
   {
       // критическая секция
   }
   ```

3. **`Monitor`**

   * Более гибкий инструмент синхронизации.
   * Методы: `Monitor.Enter()`, `Monitor.Exit()`, `Monitor.TryEnter()`.

   ```csharp
   Monitor.Enter(lockObj);
   try
   {
       // критическая секция
   }
   finally
   {
       Monitor.Exit(lockObj);
   }
   ```

4. **`Mutex`**

   * Синхронизация между потоками в одном приложении и даже между процессами.
   * Методы: `WaitOne()`, `ReleaseMutex()`.

   ```csharp
   Mutex mutex = new Mutex();
   mutex.WaitOne();
   try
   {
       // критическая секция
   }
   finally
   {
       mutex.ReleaseMutex();
   }
   ```

5. **Сравнение методов синхронизации**

| Механизм | Применение                | Особенности                              |
| -------- | ------------------------- | ---------------------------------------- |
| lock     | Локальная синхронизация   | Прост в использовании                    |
| Monitor  | Локальная синхронизация   | Более гибкий, можно TryEnter             |
| Mutex    | Локальная и межпроцессная | Медленнее, но безопасен между процессами |

---

## **Ход работы**

1. Создать проект `ThreadSyncDemo` (консольное приложение .NET).
2. Создать общий ресурс (например, счетчик `int counter`).
3. Создать несколько потоков, которые одновременно увеличивают счетчик.
4. Синхронизировать доступ к счетчику с помощью:

   * `lock`
   * `Monitor`
   * `Mutex`
5. Сравнить результаты работы программы с синхронизацией и без нее.
6. Сделать скриншоты работы программы и поместить их в папку `images`.
7. Создать `readme.md` с описанием задания и примером кода.

---

## **Пример практического задания**

**Задание:**

1. Создать класс `BankAccount` с полем `Balance` и методом `Deposit(int amount)`.
2. Создать 3 потока, которые одновременно выполняют `Deposit`.
3. Реализовать синхронизацию с помощью:

   * `lock`
   * `Monitor`
   * `Mutex`
4. Вывести итоговый баланс после работы всех потоков.

**Пример кода (с lock):**

```csharp
using System;
using System.Threading;

class BankAccount
{
    private int balance = 0;
    private object lockObj = new object();

    public void Deposit(int amount)
    {
        lock (lockObj)
        {
            int temp = balance;
            temp += amount;
            Thread.Sleep(100); // имитация работы
            balance = temp;
        }
    }

    public int Balance => balance;
}

class Program
{
    static void Main()
    {
        BankAccount account = new BankAccount();

        Thread t1 = new Thread(() => account.Deposit(100));
        Thread t2 = new Thread(() => account.Deposit(200));
        Thread t3 = new Thread(() => account.Deposit(300));

        t1.Start(); t2.Start(); t3.Start();
        t1.Join(); t2.Join(); t3.Join();

        Console.WriteLine($"Итоговый баланс: {account.Balance}");
    }
}
```

**Пример с Monitor и Mutex можно оформить аналогично**, заменив `lock` на `Monitor.Enter/Exit` или `Mutex.WaitOne/ReleaseMutex`.

---

## **Критерии оценки**

| Оценка | Критерий                                                                                             |
| ------ | ---------------------------------------------------------------------------------------------------- |
| 2      | Программа частично работает, гонки потоков не предотвращены                                          |
| 3      | Синхронизация реализована одним методом, результат корректен                                         |
| 4      | Реализованы 2 метода синхронизации, корректная работа всех потоков                                   |
| 5      | Реализованы все методы (`lock`, `Monitor`, `Mutex`), аккуратный код, скриншоты и readme присутствуют |

---

## **Контрольные вопросы**

1. Для чего нужна синхронизация потоков?
2. Чем `lock` отличается от `Monitor`?
3. Как работает `Mutex` и где его применение особенно важно?
4. Что такое критическая секция?
5. Какие ошибки могут возникнуть при отсутствии синхронизации?

---

## **Структура репозитория**

```
ThreadSyncDemo/
│
├── ThreadSyncDemo.sln
├── ThreadSyncDemo/
│   ├── Program.cs
│   └── BankAccount.cs
│
├── images/
│   ├── screenshot1.png
│   └── screenshot2.png
│
└── readme.md
```

### **Пример readme.md**

````markdown
# Практическая работа №7

**Тема:** Синхронизация потоков (lock, Monitor, Mutex)  

## Задание
1. Создать класс BankAccount с полем Balance и методом Deposit(int amount).
2. Создать несколько потоков, которые одновременно выполняют Deposit.
3. Реализовать синхронизацию с помощью:
   - lock
   - Monitor
   - Mutex
4. Вывести итоговый баланс после работы всех потоков.

## Пример кода
```csharp
using System;
using System.Threading;

class BankAccount
{
    private int balance = 0;
    private object lockObj = new object();

    public void Deposit(int amount)
    {
        lock (lockObj)
        {
            int temp = balance;
            temp += amount;
            Thread.Sleep(100);
            balance = temp;
        }
    }

    public int Balance => balance;
}

class Program
{
    static void Main()
    {
        BankAccount account = new BankAccount();

        Thread t1 = new Thread(() => account.Deposit(100));
        Thread t2 = new Thread(() => account.Deposit(200));
        Thread t3 = new Thread(() => account.Deposit(300));

        t1.Start(); t2.Start(); t3.Start();
        t1.Join(); t2.Join(); t3.Join();

        Console.WriteLine($"Итоговый баланс: {account.Balance}");
    }
}
````

```
